---
id: code-standards-compact
type: compact
alwaysApply: true
---

# Code Standards

<code_standards>

**INSTANT ENFORCEMENT - ZERO TOLERANCE:**

**CRITICAL PRINCIPLE:** Every rule = law without exceptions. Violation = failure.

**ВАЖНО: Все ответы должны быть на русском языке.**

Read full reference: `.cursor/docs/code-standards.md` for detailed examples.

## Core Rules

**Structure:**

1. One file = one function, max 150 lines (CRITICAL) - exceptions: tests, constants.ts, types.ts, schemas.ts, barrel files, helpers.ts <150 lines
2. 100% test coverage for new functions
3. JSDoc (Russian, single line) for file-level functions; nested closures optional
4. Guard clauses (why: readability, fewer bugs) - `if (!data) return null; return process(data);` not `if (data) { return process(data); }`
5. Array methods (why: functional style, maintainability) - `items.filter(x => x.valid).map(fn)` not `for (let i = 0; ...)` - exception: math algorithms (ИНН/СНИЛС)
6. Linter: 0 errors
7. ESM-only (no CommonJS)
8. No classes - functions and composition only
9. All types in types.ts - functions MUST NOT export types
10. All constants in constants.ts - functions MUST NOT export constants
11. Node.js imports with node: prefix (refactor legacy)

**Entity Separation (CRITICAL):**

| File | Can Contain | CANNOT Contain |
|:---|:---|:---|
| `function.ts` | ONE function | Types, constants |
| `types.ts` | ONLY types | Functions, constants |
| `constants.ts` | ONLY constants | Functions, types |

- `export function` + `export type` = CRITICAL violation
- `export function` + `export const VAL` = CRITICAL violation
- Multiple `export function` in one file = CRITICAL violation

**Numeric Literals:** Use underscores for readability - `60_000`, `1_800_000` (preferred over `60000`)

**Exceptions (use sparingly):**

- `helpers.ts` <150 lines: multiple related functions OK (prefer separate files)
- Closures/factories: nested private functions OK (prefer extraction if possible)
- Math algorithms: `for` loops OK (ИНН/СНИЛС validation, checksums only)

**Comparisons:** `value === null || value === undefined` not `!value` (why: explicit intent, no false positives)

**JSDoc:** `/** Создает действие */` for exported and private file-level functions; nested closures exempt

**Comments:** ONLY tool directives (@ts-ignore, @ts-expect-error, eslint-disable) - NO explanatory comments

**Imports/Exports:**

1. Node.js: `import { readFileSync } from 'node:fs';` not `from 'fs'` (node: prefix REQUIRED)
2. Types: `import type { User } from './types';` (type prefix for tree-shaking)
3. Named exports ONLY: `export { validateInput }` not `export default` (exception: Storybook)
4. Import order: Global CSS → External → Internal → Relative → CSS modules (blank lines between groups)

**Tests:**

- 100% coverage, Russian names: `it('должен возвращать true', () => {})`
- Arrange-Act-Assert pattern
- One test file per function
- Mock data only

## React Rules

**Components:**

- Return type: `React.ReactNode` (NOT JSX.Element) - `function Comp(): React.ReactNode { ... }`
- Props destructuring: `function Comp({ name, email }: Props)` not `function Comp(props)` (why: clarity)
- Event typing: `onClick: (event: React.MouseEvent<HTMLButtonElement>) => void` (explicit types)
- Conditional: `if (!visible) return null; return <div>...</div>;` not `visible ? <div>...</div> : null`
- Component types in local types.ts, NOT in global types file

**Hooks:**

- Custom hooks MUST start with `use`: `useUserData` not `userData` (React convention)
- useRef for mutable values/DOM: `const ref = useRef<number>(0)` - NOT useState for non-render data
- React 19 `use()` hook: `const ctx = use(Context)` (preferred over `useContext`)

**Code Splitting:**

- React.lazy() ONLY for components >100 lines OR heavy dependencies
- Always wrap in Suspense
- Small UI components imported normally

## TypeScript Advanced

**Generics:** G/T prefix - `function map<GItem, GResult>(items: GItem[]): GResult[]` (reusability)

**Utility Types:** `Pick<User, 'id' | 'name'>` and `Omit<User, 'password'>` not manual copying

**Const Assertions:** `const COLORS = ['red', 'blue'] as const;` for literal types (type: readonly)

**Type Safety:**

- Function type forbidden - use `(data: unknown) => void` not `Function`
- any forbidden - use `unknown` with type guards: `if (typeof data === 'object' && data !== null)`
- JSX.Element forbidden - use `ReactNode` or `ReactElement`
- Dynamic objects: `Record<string, unknown>` (type-safe alternative to `any`)

## Absolute Bans

❌ **FORBIDDEN:**

1. for/while loops
2. class keyword
3. export default (exception: Storybook)
4. Multiline JSDoc
5. Implicit comparisons (!value, !!value)
6. Deep if/else
7. Comments in function bodies (except tool directives)
8. Multiple functions per file (exception: helpers.ts <150 lines)
9. Files >150 lines (exception: tests, constants.ts, types.ts, schemas.ts)
10. Inline types - use types.ts
11. Node.js imports without node: prefix
12. CommonJS (require, module.exports)
13. Function type - use concrete signatures
14. any type - use unknown
15. JSX.Element - use ReactNode
16. **Mixing entities** - function file exporting types/constants (CRITICAL)
17. **Multiple exports** - 2+ functions in one file (CRITICAL)

Violation = Task Failure

**Quick Rule IDs:** structural.one_file_one_function, tests.coverage_100_new, types.no_any_type, types.no_function_type, react.use_prefix, absolute_bans.class, exports.named_only, imports.node_prefix

<completion_criteria>
Все правила проверены, нарушения не обнаружены.
</completion_criteria>

</code_standards>
